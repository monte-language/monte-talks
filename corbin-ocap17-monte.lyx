#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{url}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "Liberation Serif"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format pdf5
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Monte: A Spiritual Successor to E
\end_layout

\begin_layout Author
Corbin Simpson
\end_layout

\begin_layout Abstract
We introduce Monte, a capability-safe programming language in the style
 of E.
 We detail several of Monte's differences from E, including new syntax,
 several new interfaces, and a simple module model.
 In particular, we examine four features and their consequences for secure
 distributed computing: named arguments, iterators, modules, and controllers.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Monte is a programming language cast in the same mold as E.
 Like E, Monte is a capability-safe language which models capabilities as
 objects (the 
\begin_inset Quotes eld
\end_inset

object-capability
\begin_inset Quotes erd
\end_inset

 security model).
 Also like E, Monte expands from a rich sugared language, Full-Monte, to
 a strict subset, Kernel-Monte.
 In fact, Kernel-Monte is almost exactly like Kernel-E, and we discuss named
 arguments and iterators, the two largest divergences that Kernel-Monte
 makes from Kernel-E.
\end_layout

\begin_layout Section
Named Arguments
\end_layout

\begin_layout Standard
In addition to positional arguments, Monte supports passing arguments keyed
 by name.
\end_layout

\begin_layout Standard
Keys are often strings, and the syntax admits them as a special case:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def makeRectangle(=> width, => height):
\end_layout

\begin_layout Plain Layout

    return object rectangle:
\end_layout

\begin_layout Plain Layout

        to getWidth():
\end_layout

\begin_layout Plain Layout

            return width
\end_layout

\begin_layout Plain Layout

        to getHeight():
\end_layout

\begin_layout Plain Layout

            return height
\end_layout

\begin_layout Plain Layout

def rect := makeRectangle("width" => 5, "height" => 7)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Default values are supported as well:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def adjustAndPad(adjustment, => padding :Str := " "):
\end_layout

\begin_layout Plain Layout

    adjust(adjustment)
\end_layout

\begin_layout Plain Layout

    pad(padding)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Under the hood, Monte accomodates all of this functionality with a very
 simple change of semantics.
 In E, a message is [verb :Str, args :List].
 However, in Monte, a message is [verb :Str, args :List, namedArgs :Map].
\end_layout

\begin_layout Subsection
Locked Methods
\end_layout

\begin_layout Standard
The keys can be arbitrary objects.
 Indeed, consider what happens when a closely-held object is used as a key:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object sesame {}
\end_layout

\begin_layout Plain Layout

object riches {}
\end_layout

\begin_layout Plain Layout

def cave((sesame) => _):
\end_layout

\begin_layout Plain Layout

    return riches
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function can only be called when the caller passes the right key, and
 otherwise it will not perform any effects in the method body.
 Since the key is passed as a named argument, it won't interfere with any
 other arguments.
 Therefore, we can apply this pattern to any method.
 We call this the 
\begin_inset Quotes eld
\end_inset

locked method
\begin_inset Quotes erd
\end_inset

 pattern since the method's named parameter is like a lock to which the
 key is applied.
\end_layout

\begin_layout Standard
Locked methods are largely equivalent in functionality to sealed dispatch,
 where a brand is passed to the ._sealedDispatch() Miranda method.
 
\begin_inset CommandInset citation
LatexCommand cite
key "MonteMiranda"

\end_inset

 However, there are key differences that hint at different use cases.
 Locked methods are not as suavely clandestine as sealed dispatch, since
 they form part of the default alleged interface.
\end_layout

\begin_layout Section
Iterators
\end_layout

\begin_layout Standard
E has internal iteration.
 Monte has explicit iterators instead, with an iterable protocol:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def counter._makeIterator():
\end_layout

\begin_layout Plain Layout

    var i :Int := 0
\end_layout

\begin_layout Plain Layout

    return object iterator.next(_ej):
\end_layout

\begin_layout Plain Layout

        def rv := [i, i]
\end_layout

\begin_layout Plain Layout

        i += 1
\end_layout

\begin_layout Plain Layout

        return rv
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These two methods, ._makeIterator/0 and .next/1, are the entire protocol.
 Iterators may call the passed-in ejector to end iteration, or they may
 return a pair.
 Iteration always proceeds over pairs.
 The first element of the pair is usually a key or index, while the second
 element is a keyed value or datum.
 Iteration over lists yields pairs of indices and values, like Python's
 enumerate().
 Iteration over maps yields key-value pairs.
\end_layout

\begin_layout Standard
We can recover classic map-and-filter behavior with list comprehension syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def stop := 20
\end_layout

\begin_layout Plain Layout

def oddInts := [for i in (0..!stop) ? (i % 2 == 1) i]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, the 
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset

 should be read as 
\begin_inset Quotes eld
\end_inset

such-that
\begin_inset Quotes erd
\end_inset

, just like in such-that patterns, and performs a filtering operation, skipping
 iterations where the such-that condition fails.
\end_layout

\begin_layout Section
Modules
\end_layout

\begin_layout Standard
A Monte module is both a compilation unit and a composable code unit.
 We replace E URI-getters and maker files with a uniform module interface.
\end_layout

\begin_layout Subsection
Imports & Exports
\end_layout

\begin_layout Standard
At the highest level, a module is a source file with a header which indicates
 the exports and imports of the module.
 After compilation, the module can be given a name and composed with other
 modules by piping exports to imports.
 The composition is performed by a module loader, which is a plain Monte
 expression empowered to load code objects.
\end_layout

\begin_layout Standard
Module syntax is relatively light.
 Here is a complete, if facetious, module which imports from 
\begin_inset Quotes eld
\end_inset

lib/iterators
\begin_inset Quotes erd
\end_inset

 and exports a single name, 
\begin_inset Quotes eld
\end_inset

zipSum
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import "lib/iterators" =~ [=> zip :DeepFrozen]
\end_layout

\begin_layout Plain Layout

exports (zipSum)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def zipSum(left :List, right :List) :List as DeepFrozen:
\end_layout

\begin_layout Plain Layout

  return [for [l, r] in (zip(left, right)) l + r]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Expanding only the module syntax, the structure of a module is revealed
 to be a simple anonymous object:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object _ as DeepFrozen:
\end_layout

\begin_layout Plain Layout

  to dependencies() :List[Str]:
\end_layout

\begin_layout Plain Layout

    return ["lib/iterators"]
\end_layout

\begin_layout Plain Layout

  to run(package) :Map[Str, DeepFrozen]:
\end_layout

\begin_layout Plain Layout

    def [=> zip :DeepFrozen] | _ := package."import"("lib/iterators")
\end_layout

\begin_layout Plain Layout

    def zipSum(left :List, right :List) :List as DeepFrozen:
\end_layout

\begin_layout Plain Layout

      return [for [l, r] in (zip(left, right)) l + r]
\end_layout

\begin_layout Plain Layout

    return [=> zipSum]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While arbitrary patterns are allowed in imports, we encourage a convention
 of map-patterns.
 Notice that we expand 
\begin_inset Quotes eld
\end_inset

[=> zip :DeepFrozen]
\begin_inset Quotes erd
\end_inset

 into 
\begin_inset Quotes eld
\end_inset

[=> zip :DeepFrozen] | _
\begin_inset Quotes erd
\end_inset

, which is a convenience that both allows users to import only needed names
 and also allows for modules to add new exports without breaking users,
 making it easier to expand a module's interface without breaking compatibility.
\end_layout

\begin_layout Subsection
DeepFrozen Exports
\end_layout

\begin_layout Standard
In Monte, module exports must conform to DeepFrozen.
 This constraint forces modules to do any impure or mutable computation
 prior to freezing and returning exported values.
\end_layout

\begin_layout Standard
There are several boons to the DeepFrozen requirement.
 Like E makers, Monte modules can be cached and composed.
 Module composition proceeds with the assistance of a module loader, which
 is a short routine that loads modules and incrementally executes them,
 routing exports to imports.
\end_layout

\begin_layout Standard
There are some difficulties, too.
 In particular, imported names often must be guarded by DeepFrozen, which
 is an irritating syntactic burden.
 The only common exception is importing from the special 
\begin_inset Quotes eld
\end_inset

unittest
\begin_inset Quotes erd
\end_inset

 name, which produces an effect on import in order to run unit tests.
 Such impure effects executed on import don't alter the module formalism
 at all, just the implementation of the module loader.
 The impurity of the loader also lets us cache and reuse modules as plain
 objects, so that modules which occur often in the module dependency graph
 can be reused.
\end_layout

\begin_layout Subsection
Entrypoints
\end_layout

\begin_layout Standard
To replace E's URI getters, we instead designate the exported name 
\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset

 as an entrypoint for modules.
 To run an entrypoint, we pass it a message [
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

, argv :List[Str], unsafeScope :Map] and expect a Vow[Int].
 The return value and list of arguments parallel the classic inputs and
 outputs to an OS process, while the unsafe scope consists of all of the
 primitive powers which the loader is willing to grant to the program at
 large.
\end_layout

\begin_layout Standard
This interface permits easy examination of coarse OS-level capabilities,
 akin to BSD pledge()/tame().
 Consider the following entrypoint, from an IRC client:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def main(argv :List[Str],
\end_layout

\begin_layout Plain Layout

         => Timer,
\end_layout

\begin_layout Plain Layout

         => currentRuntime,
\end_layout

\begin_layout Plain Layout

         => getAddrInfo,
\end_layout

\begin_layout Plain Layout

         => makeFileResource,
\end_layout

\begin_layout Plain Layout

         => makeTCP4ClientEndpoint,
\end_layout

\begin_layout Plain Layout

         => unsealException) :Vow[Int] as DeepFrozen:
\end_layout

\begin_layout Plain Layout

  …
\end_layout

\begin_layout Plain Layout

  return 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can consider the broad capabilities of this program entirely by considering
 its unsafe named arguments in the entrypoint.
 As we do so, we can imagine a code reviewer's rationale for each name:
\end_layout

\begin_layout Description
Timer It can read the system clock and measure time taken during vat turns.
 This is needed to provide a wall-clock IRC message throttle, so that messages
 aren't lost and the bot isn't kicked.
\end_layout

\begin_layout Description
currentRuntime It can access various runtime-specific capabilities.
 This object is meant for staging non-standard platform-specific functionality.
 In this particular case, Typhon exports a non-standard cryptographic interface
 based on libsodium via currentRuntime.getCrypt().
\end_layout

\begin_layout Description
getAddrInfo It can resolve hostnames using the system DNS configuration.
 This is needed to find IRC server addresses.
\end_layout

\begin_layout Description
makeFileResource It can read and write to the filesystem.
 This is needed for storing todo lists.
\end_layout

\begin_layout Description
makeTCP4ClientEndpoint It can create TCP/IPv4 outgoing connections.
 This is needed to connect to IRC.
\end_layout

\begin_layout Description
unsealException It can examine exceptions caught by try-expressions.
 This is needed for REPL functionality.
\end_layout

\begin_layout Standard
Most of these unsafe powers have been well-studied, although the ability
 to unseal exceptions has traditionally not been separated and treated as
 unsafe.
\end_layout

\begin_layout Standard
In addition to the unsafe named parameters, an entrypoint is also passed
 a list of input strings and should return an integer indicating success
 or otherwise, as is traditional.
 One change from tradition, however, is the ability to return a promise
 for an integer instead.
 This enables an entrypoint to implicitly indicate that it has more turns
 pending before it will be finished running.
 This design is based on Twisted Python's twisted.internet.task.react() helper,
 which was designed to make it easier to produce Twisted-compatible entrypoints.
\end_layout

\begin_layout Section
Controllers
\end_layout

\begin_layout Standard
We have experienced use cases for the experimental 
\begin_inset Quotes eld
\end_inset

lambda-args
\begin_inset Quotes erd
\end_inset

 syntax suggested for E.
 In particular, we have found that computations which carry an implicit
 context or effect can be well-modeled with the syntax, and so we have adapted
 it for Monte, dubbing this syntax the controller interface.
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
A controller is a DeepFrozen object which can build a plan incrementally
 from small program fragments and instructions.
 The plan is encoded syntactically.
 A listing is worth a thousand words.
 Here is a controller in Full-Monte:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

controller (in0, …, ini) do arg0, …, argj { action() }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the same controller, with only controller syntax desugared:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(controller :DeepFrozen).control("do", i, j, fn {
\end_layout

\begin_layout Plain Layout

  [[in0, …, ini], fn param0, …, paramj, ej {
\end_layout

\begin_layout Plain Layout

    def [arg0, …, argj] exit ej := [param0, …, paramj]
\end_layout

\begin_layout Plain Layout

    action()
\end_layout

\begin_layout Plain Layout

  }]
\end_layout

\begin_layout Plain Layout

}).controlRun()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This controller receives a single command, consisting of an instruction
 
\begin_inset Quotes eld
\end_inset

do
\begin_inset Quotes erd
\end_inset

, an arity 
\begin_inset Formula $i$
\end_inset

 of inputs 
\begin_inset Formula $[in_{0},in_{1},\dots,in_{i}]$
\end_inset

, an arity 
\begin_inset Formula $j$
\end_inset

 of arguments 
\begin_inset Formula $[arg_{0},arg_{1},\dots,arg_{j}]$
\end_inset

, and a thunk known as the block.
 When called, the block returns a pair containing a list of all 
\begin_inset Formula $i$
\end_inset

 inputs and another thunk, known as the lambda.
 The lambda is the user-provided part of the plan; when called, it will
 take in 
\begin_inset Formula $j$
\end_inset

 parameters and run the user-specified action.
 The controller is expected to generate a plan based on the contents of
 the block; the plan will probably call the block, extract the inputs, pass
 the inputs to the lambda, and return the lambda's return value.
 Since the block and lambda are both thunks, they may be called zero-or-more
 times based on the design of the controller.
\end_layout

\begin_layout Subsection
Monads
\end_layout

\begin_layout Standard
Monadic actions can be fully captured by controllers.
 Compare and contrast the following Haskell:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return 42 >>= 
\backslash
x -> do {
\end_layout

\begin_layout Plain Layout

  return $ x + 1
\end_layout

\begin_layout Plain Layout

} >>= 
\backslash
x -> do {
\end_layout

\begin_layout Plain Layout

  return $ x * 2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the following Monte:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m (m.unit(42)) do x {
\end_layout

\begin_layout Plain Layout

  m.unit(x + 1)
\end_layout

\begin_layout Plain Layout

} lift x {
\end_layout

\begin_layout Plain Layout

  x * 2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We must pass our monad controller 
\begin_inset Formula $m$
\end_inset

 since we have neither implicit parameters nor typeclasses.
 The 
\begin_inset Quotes eld
\end_inset

do
\begin_inset Quotes erd
\end_inset

 instruction takes some values extracted from the monadic context and returns
 a monadic action.
 The 
\begin_inset Quotes eld
\end_inset

lift
\begin_inset Quotes erd
\end_inset

 instruction is similar, but performs an automatic unit wrapping to return
 to the monadic context.
\end_layout

\begin_layout Subsection
Kanren
\end_layout

\begin_layout Standard
Logic programming can be difficult without a domain-specific language.
 The Kanren family, including miniKanren and µKanren, is a popular choice
 for embedding logic programming into general-purpose languages.
\end_layout

\begin_layout Standard
We can construct a Kanren program from a controller.
 This simple program creates two logic variables, 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, and asserts that 
\begin_inset Formula $x\equiv\text{true}\land x\equiv y$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kanren () exists x, y {
\end_layout

\begin_layout Plain Layout

  kanren.unify(x, true)
\end_layout

\begin_layout Plain Layout

  kanren.unify(x, y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When values are extracted from this program, there will be one satisfying
 assignment, where both 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are assigned true.
\end_layout

\begin_layout Standard
While the 
\begin_inset Quotes eld
\end_inset

exists
\begin_inset Quotes erd
\end_inset

 instruction might be the main workhorse for program fragments, our Kanren
 controller is also capable of composing logic programs.
 In this example from real-world code, we compose many fragments of logic
 at the edges of a sheaf into a single coherent assignment, using the 
\begin_inset Quotes eld
\end_inset

forAll
\begin_inset Quotes erd
\end_inset

 instruction to unify a list of logic variables:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kanren (fullSection) forAll v, value {
\end_layout

\begin_layout Plain Layout

  kanren.unify(vars[index[v]], value)                
\end_layout

\begin_layout Plain Layout

} (consistency) forAll vs, goalMaker {
\end_layout

\begin_layout Plain Layout

  def swizzle := [for v in (vs) vars[index[v]]]             
\end_layout

\begin_layout Plain Layout

  M.call(goalMaker, "run", swizzle, [].asMap())
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "corbin-ocap17-monte"
options "plain"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Example Monte Module
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/simpson/typhon/mast/lib/entropy/pi.mt"
lstparams "inputencoding=utf8,extendedchars=true,caption={lib/entropy/pi.mt from the Typhon standard library}"

\end_inset


\end_layout

\end_body
\end_document
