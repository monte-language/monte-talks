#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "Liberation Serif"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format pdf5
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Monte: A Spiritual Successor to E
\end_layout

\begin_layout Author
Corbin Simpson
\end_layout

\begin_layout Abstract
We introduce Monte, a capability-safe programming language in the style
 of E.
 We detail several of Monte's differences from E, including new syntax,
 several new interfaces, and a simple module model.
 In particular, we examine four features: named arguments, iterators, modules,
 and controllers.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Monte is a programming language cast in the same mold as E.
 Like E, Monte is a capability-safe language which models capabilities as
 objects (the 
\begin_inset Quotes eld
\end_inset

object-capability
\begin_inset Quotes erd
\end_inset

 security model).
 Also like E, Monte expands from a rich sugared language, Full-Monte, to
 a strict subset, Kernel-Monte.
 In fact, Kernel-Monte is almost exactly like Kernel-E, and we discuss named
 arguments and iterators, the two largest divergences that Kernel-Monte
 makes from Kernel-E.
\end_layout

\begin_layout Section
Named Arguments
\end_layout

\begin_layout Standard
In addition to positional arguments, Monte supports passing arguments keyed
 by name.
 The keys can be arbitrary objects:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object namedKey {}
\end_layout

\begin_layout Plain Layout

def requireKey((namedKey) => value):
\end_layout

\begin_layout Plain Layout

    return value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Keys are often strings, and the syntax admits them as a special case:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def makeRectangle(=> width, => height):
\end_layout

\begin_layout Plain Layout

    return object rectangle:
\end_layout

\begin_layout Plain Layout

        to getWidth():
\end_layout

\begin_layout Plain Layout

            return width
\end_layout

\begin_layout Plain Layout

        to getHeight():
\end_layout

\begin_layout Plain Layout

            return height
\end_layout

\begin_layout Plain Layout

def rect := makeRectangle("width" => 5, "height" => 7)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Default values are supported as well:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def adjustAndPad(adjustment, => padding :Str := " "):
\end_layout

\begin_layout Plain Layout

    adjust(adjustment)
\end_layout

\begin_layout Plain Layout

    pad(padding)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Under the hood, Monte accomodates all of this functionality with a very
 simple change of semantics.
 In E, a message is [verb :Str, args :List].
 However, in Monte, a message is [verb :Str, args :List, namedArgs :Map].
\end_layout

\begin_layout Section
Iterators
\end_layout

\begin_layout Standard
E has internal iteration.
 Monte has explicit iterators instead, with an iterable protocol:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def counter._makeIterator():
\end_layout

\begin_layout Plain Layout

    var i :Int := 0
\end_layout

\begin_layout Plain Layout

    return object iterator.next(_ej):
\end_layout

\begin_layout Plain Layout

        def rv := [i, i]
\end_layout

\begin_layout Plain Layout

        i += 1
\end_layout

\begin_layout Plain Layout

        return rv
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These two methods, ._makeIterator/0 and .next/1, are the entire protocol.
 Iterators may call the passed-in ejector to end iteration, or they may
 return a pair.
 Iteration always proceeds over pairs.
 The first element of the pair is usually a key or index, while the second
 element is a keyed value or datum.
 Iteration over lists yields pairs of indices and values, like Python's
 enumerate().
 Iteration over maps yields key-value pairs.
\end_layout

\begin_layout Standard
We can recover classic map-and-filter behavior with list comprehension syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def stop := 20
\end_layout

\begin_layout Plain Layout

def oddInts := [for i in (0..!stop) ? (i % 2 == 1) i]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Modules
\end_layout

\begin_layout Standard
A Monte module is both a compilation unit and a composable code unit.
 We replace E URI imports and maker files with a uniform module interface.
\end_layout

\begin_layout Standard
At the highest level, a module is a source file with a header which indicates
 the exports and imports of the module.
 After compilation, the module can be given a name and composed with other
 modules by piping exports to imports.
 The composition is performed by a module loader, which is a plain Monte
 expression empowered to load code objects.
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/simpson/typhon/mast/lib/entropy/pi.mt"
lstparams "inputencoding=utf8,extendedchars=true,caption={lib/entropy/pi.mt from the Typhon standard library}"

\end_inset


\end_layout

\begin_layout Standard
Consider this short real module from the Typhon interpreter's standard library.
 It imports from two modules, and exports a single name which can be imported
 elsewhere.
 While the module is named 
\begin_inset Quotes eld
\end_inset

lib/entropy/pi
\begin_inset Quotes erd
\end_inset

 by its filename, that name doesn't appear in the module itself; modules
 are anonymous to themselves.
\end_layout

\begin_layout Standard
Module exports must conform to DeepFrozen.
 As a result, imported names often must be guarded by DeepFrozen.
 We can make an exception for unit tests because they can be treated as
 impure effects executed on import; this doesn't alter the module formalism
 at all, just the module loader.
 The impurity of the loader also lets us cache and reuse modules as plain
 objects, so that modules which occur often in the module dependency graph
 can be reused.
\end_layout

\begin_layout Standard
To replace E's URI lookup mechanism, we instead designate the export name
 
\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset

 as an entrypoint for modules.
 To run an entrypoint, we pass it a message [
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

, argv :List[Str], unsafeScope :Map] and expect a Vow[Int].
 The return value and list of arguments parallel the classic inputs and
 outputs to an OS process, while the unsafe scope consists of all of the
 primitive powers which the loader is willing to grant to the program at
 large.
\end_layout

\begin_layout Section
Controllers
\end_layout

\begin_layout Standard
We have experienced use cases for the E experimental 
\begin_inset Quotes eld
\end_inset

lambda-args
\begin_inset Quotes erd
\end_inset

 syntax.
 In particular,we have found that computations which carry an implicit context
 or effect can be well-modeled with the syntax, and so we have adapted it
 for Monte, dubbing this syntax the controller interface.
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
A controller is a DeepFrozen object which can build a plan incrementally
 from small program fragments and instructions.
 The plan is encoded syntactically.
 A listing is worth a thousand words.
 Here is a controller in Full-Monte:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

controller (in0, …, ini) do arg0, …, argj { action() }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the same controller, with only controller syntax desugared:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(controller :DeepFrozen).control("do", i, j, fn {
\end_layout

\begin_layout Plain Layout

  [[in0, …, ini], fn param0, …, paramj, ej {
\end_layout

\begin_layout Plain Layout

    def [arg0, …, argj] exit ej := [param0, …, paramj]
\end_layout

\begin_layout Plain Layout

    action()
\end_layout

\begin_layout Plain Layout

  }]
\end_layout

\begin_layout Plain Layout

}).controlRun()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This controller receives a single command, consisting of an instruction
 
\begin_inset Quotes eld
\end_inset

do
\begin_inset Quotes erd
\end_inset

, an arity 
\begin_inset Formula $i$
\end_inset

 of inputs 
\begin_inset Formula $[in_{0},in_{1},\dots,in_{i}]$
\end_inset

, an arity 
\begin_inset Formula $j$
\end_inset

 of arguments 
\begin_inset Formula $[arg_{0},arg_{1},\dots,arg_{j}]$
\end_inset

, and a thunk known as the block.
 When called, the block returns a pair containing a list of all 
\begin_inset Formula $i$
\end_inset

 inputs and another thunk, known as the lambda.
 The lambda is the user-provided part of the plan; when called, it will
 take in 
\begin_inset Formula $j$
\end_inset

 parameters and run the user-specified action.
 The controller is expected to generate a plan based on the contents of
 the block; the plan will probably call the block, extract the inputs, pass
 the inputs to the lambda, and return the lambda's return value.
 Since the block and lambda are both thunks, they may be called zero-or-more
 times based on the design of the controller.
\end_layout

\begin_layout Subsection
Monads
\end_layout

\begin_layout Standard
Monadic actions can be fully captured by controllers.
 Compare and contrast the following Haskell:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return 42 >>= 
\backslash
x -> do {
\end_layout

\begin_layout Plain Layout

  return $ x + 1
\end_layout

\begin_layout Plain Layout

} >>= 
\backslash
x -> do {
\end_layout

\begin_layout Plain Layout

  return $ x * 2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the following Monte:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m (m.unit(42)) do x {
\end_layout

\begin_layout Plain Layout

  m.unit(x + 1)
\end_layout

\begin_layout Plain Layout

} lift x {
\end_layout

\begin_layout Plain Layout

  x * 2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We must pass our monad controller 
\begin_inset Formula $m$
\end_inset

 since we have neither implicit parameters nor typeclasses.
 The 
\begin_inset Quotes eld
\end_inset

do
\begin_inset Quotes erd
\end_inset

 instruction takes some values extracted from the monadic context and returns
 a monadic action.
 The 
\begin_inset Quotes eld
\end_inset

lift
\begin_inset Quotes erd
\end_inset

 instruction is similar, but performs an automatic unit wrapping to return
 to the monadic context.
\end_layout

\begin_layout Subsection
Kanren
\end_layout

\begin_layout Standard
Logic programming can be difficult without a domain-specific language.
 The Kanren family, including miniKanren and µKanren, is a popular choice
 for embedding logic programming into general-purpose languages.
\end_layout

\begin_layout Standard
We can construct a Kanren program from a controller.
 This simple program creates two logic variables, 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, and asserts that 
\begin_inset Formula $x\equiv\text{true}\land x\equiv y$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kanren () exists x, y {
\end_layout

\begin_layout Plain Layout

  kanren.unify(x, true)
\end_layout

\begin_layout Plain Layout

  kanren.unify(x, y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When values are extracted from this program, there will be one satisfying
 assignment, where both 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are assigned true.
\end_layout

\begin_layout Standard
While the 
\begin_inset Quotes eld
\end_inset

exists
\begin_inset Quotes erd
\end_inset

 instruction might be the main workhorse for program fragments, our Kanren
 controller is also capable of composing logic programs.
 In this example from real-world code, we compose many fragments of logic
 at the edges of a sheaf into a single coherent assignment, using the 
\begin_inset Quotes eld
\end_inset

forAll
\begin_inset Quotes erd
\end_inset

 instruction to unify a list of logic variables:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kanren (fullSection) forAll v, value {
\end_layout

\begin_layout Plain Layout

  kanren.unify(vars[index[v]], value)                
\end_layout

\begin_layout Plain Layout

} (consistency) forAll vs, goalMaker {
\end_layout

\begin_layout Plain Layout

  def swizzle := [for v in (vs) vars[index[v]]]             
\end_layout

\begin_layout Plain Layout

  M.call(goalMaker, "run", swizzle, [].asMap())
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
